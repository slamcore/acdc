__copyright__ = """
    SLAMcore Limited
    All Rights Reserved.
    (C) Copyright 2022

    NOTICE:

    All information contained herein is, and remains the property of SLAMcore
    Limited and its suppliers, if any. The intellectual and technical concepts
    contained herein are proprietary to SLAMcore Limited and its suppliers and
    may be covered by patents in process, and are protected by trade secret or
    copyright law.
"""

__license__ = "CC BY-NC-SA 3.0"

import collections
import os
from typing import Any, Dict, List

import numpy as np
from loguru import logger

from acdc.metrics.metric import Metric
from acdc.utils.common import read_image
from acdc.utils.types import ArrayAny, ArrayF32, ListOfTensor


class DepthMetrics(Metric):
    """Depth metrics"""

    def __init__(self, pred_depth_label: str, min_depth: float, max_depth: float):
        """Constructor

        :param pred_depth_label: label of predicted depth
        :param min_depth: Minimum depth (meters)
        :param max_depth: Maximum depth (meters)
        """
        super().__init__()
        self.pred_depth_label = pred_depth_label
        self.min_depth = min_depth
        self.max_depth = max_depth
        assert min_depth > 0.0
        assert max_depth > min_depth

    def _compute_metrics(
        self, gt: ArrayF32, pred: ArrayF32, mask: ArrayF32
    ) -> Dict[str, float]:
        """Compute metrics

        :param gt: Ground truth depth
        :param pred: Predicted depth
        :param mask: Mask of valid GT values
        :return: Metrics
        """
        metrics = collections.OrderedDict()
        metrics["abs_rel"] = np.mean(np.abs(gt - pred) / gt)
        metrics["sq_rel"] = np.mean(((gt - pred) ** 2) / gt)

        metrics["mae"] = np.mean(abs(gt - pred))
        metrics["mse"] = np.mean((gt - pred) ** 2)

        rmse = (gt - pred) ** 2
        metrics["rmse"] = np.sqrt(rmse.mean())

        rmse_log = (np.log(gt) - np.log(pred)) ** 2
        metrics["rmse_log"] = np.sqrt(rmse_log.mean())

        thresh = np.maximum((gt / pred), (pred / gt))
        metrics["a1"] = (thresh < 1.25).mean()
        metrics["a2"] = (thresh < 1.25 ** 2).mean()
        metrics["a3"] = (thresh < 1.25 ** 3).mean()

        metrics["n_pixels"] = mask.sum()

        return metrics

    def load_result(
        self, result_folder: str, filename: str, info: Dict[str, Any]
    ) -> Dict[str, List[ArrayAny]]:
        """Load results from disk

        :param result_folder: Results folder
        :param filename: Name of Gt file
        :param info: Info for this batch sample
        :return: Results
        """
        filepath = os.path.join(result_folder, f"depth_{filename}_0.png")
        # file name generated by "activedepthcompletion" repo
        if not os.path.isfile(filepath):
            filepath = os.path.join(result_folder, f"{filename}_depth.png")

        depth = read_image(filepath)
        assert depth.dtype == np.uint16
        assert depth.ndim == 2
        depth = depth.astype(np.float32) / 1000

        results = {self.pred_depth_label: [depth]}
        return results

    def aggregate(self, metric_data: List[Dict[str, float]]) -> Dict[str, float]:
        """Aggregates the results of images

        :param metric_data: List of results for images produced by compute
        :return: Final aggregated results
        """
        n_pixels = sum([m["n_pixels"] for m in metric_data])
        n_pixels_w_initial = sum([m["n_pixels_w_initial"] for m in metric_data])
        n_pixels_wo_initial = sum([m["n_pixels_wo_initial"] for m in metric_data])
        results = {}
        for metric in metric_data:
            for k, v in metric.items():
                if k not in results:
                    results[k] = 0.0

                results[k] += v / len(metric_data)

        results["n_pixels"] = n_pixels
        results["n_pixels_w_initial"] = n_pixels_w_initial
        results["n_pixels_wo_initial"] = n_pixels_wo_initial

        return results

    def compute(
        self,
        data: Dict[str, ListOfTensor],
        output: Dict[str, ListOfTensor],
        info: Dict[str, Any],
    ) -> List[Dict[str, Any]]:
        """Computes the metrics for one batch of images

        :param data: Input data
        :param output: Network output
        :param info: Data info
        :return: List of results for one batch of images
        """
        gt_depth_batch = data["depth_gt"][0].numpy()
        pred_depth_batch = output["depth"][0].cpu().numpy()
        initial_depth_valid_mask_batch = data["valid_mask"][0].numpy()
        batch_size = gt_depth_batch.shape[0]

        assert gt_depth_batch.shape == pred_depth_batch.shape
        assert initial_depth_valid_mask_batch.shape == pred_depth_batch.shape

        metrics_batch = []
        for batch in range(batch_size):
            gt_depth = gt_depth_batch[batch, 0, ...]
            pred_depth = pred_depth_batch[batch, 0, ...]
            initial_depth_valid = initial_depth_valid_mask_batch[batch, 0, ...]

            num_pixels = pred_depth.shape[0] * pred_depth.shape[1]
            completeness = np.sum(pred_depth > 0) / num_pixels

            gt_depth_w_initial = gt_depth[initial_depth_valid == 1]
            gt_depth_wo_initial = gt_depth[initial_depth_valid == 0]
            pred_depth_w_initial = pred_depth[initial_depth_valid == 1]
            pred_depth_wo_initial = pred_depth[initial_depth_valid == 0]

            mask = np.logical_and(gt_depth > self.min_depth, gt_depth < self.max_depth)
            mask_w_initial = np.logical_and(
                gt_depth_w_initial > self.min_depth, gt_depth_w_initial < self.max_depth
            )
            mask_wo_initial = np.logical_and(
                gt_depth_wo_initial > self.min_depth, gt_depth_wo_initial < self.max_depth
            )

            pred_depth = pred_depth[mask]
            gt_depth = gt_depth[mask]

            pred_depth_w_initial = pred_depth_w_initial[mask_w_initial]
            gt_depth_w_initial = gt_depth_w_initial[mask_w_initial]

            pred_depth_wo_initial = pred_depth_wo_initial[mask_wo_initial]
            gt_depth_wo_initial = gt_depth_wo_initial[mask_wo_initial]

            pred_depth[pred_depth < self.min_depth] = self.min_depth
            pred_depth[pred_depth > self.max_depth] = self.max_depth

            pred_depth_w_initial[pred_depth_w_initial < self.min_depth] = self.min_depth
            pred_depth_w_initial[pred_depth_w_initial > self.max_depth] = self.max_depth

            pred_depth_wo_initial[pred_depth_wo_initial < self.min_depth] = self.min_depth
            pred_depth_wo_initial[pred_depth_wo_initial > self.max_depth] = self.max_depth

            metrics = self._compute_metrics(gt_depth, pred_depth, mask)
            metrics["completeness"] = completeness

            if len(gt_depth_w_initial) > 0:
                metrics_w_initial = self._compute_metrics(
                    gt_depth_w_initial, pred_depth_w_initial, mask_w_initial
                )
                for k, v in metrics_w_initial.items():
                    metrics[k + "_w_initial"] = v
            else:
                metrics["n_pixels_w_initial"] = 0

            if len(gt_depth_wo_initial) > 0:
                metrics_wo_initial = self._compute_metrics(
                    gt_depth_wo_initial, pred_depth_wo_initial, mask_wo_initial
                )
                for k, v in metrics_wo_initial.items():
                    metrics[k + "_wo_initial"] = v
            else:
                metrics["n_pixels_wo_initial"] = 0

            metrics_batch.append(metrics)

        return metrics_batch

    def print(self, metric_data: Dict[str, Any]) -> None:
        """Print results

        :param metric_data: Results
        """
        # standard statistics
        stat_str = ""
        for key in metric_data.keys():
            if "_initial" not in key:
                stat_str += "{:>8} | ".format(key)
        stat_str += "\n"

        for key, value in metric_data.items():
            if "_initial" not in key:
                stat_str += "&{: 8.4f} ".format(value)
        stat_str += "\\\\"
        stat_str += "\n\n"

        # w_initial standard statistics
        for key in metric_data.keys():
            if "_w_initial" in key:
                stat_str += "{:>8} | ".format(key)
        stat_str += "\n"

        for key, value in metric_data.items():
            if "_w_initial" in key:
                stat_str += "&{: 8.4f} ".format(value)
        stat_str += "\\\\"
        stat_str += "\n\n"

        # wo_initial standard statistics
        for key in metric_data.keys():
            if "_wo_initial" in key:
                stat_str += "{:>8} | ".format(key)
        stat_str += "\n"

        for key, value in metric_data.items():
            if "_wo_initial" in key:
                stat_str += "&{: 8.4f} ".format(value)
        stat_str += "\\\\"
        stat_str += "\n\n"

        logger.info(stat_str)
